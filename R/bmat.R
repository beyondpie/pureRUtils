#' Shuffle bmat in both row and column.
#' @param bmat sparseMatrix, cell by bins
#' @return sparseMatrix
#' @export
shuffleBmat <- function(bmat) {
  cnt <- sum(bmat)
  nrow <- nrow(bmat)
  ncol <- ncol(bmat)
  message("Counts from bmat: ", cnt)
  message("bmat dim: ", nrow, " x ", ncol)
  r <- tryCatch(
    expr = {
      i <- sample(length(bmat), size = cnt)
      jth <- i %% ncol
      jth[jth == 0] <- ncol
      ith <- ceiling(i / ncol)
      Matrix::sparseMatrix(i = ith, j = jth, x = 1)
    }, error = function(cond) {
      message("ShuffleBmat faces errors.")
      message(cond)
      message("Use sample row and column way.")
      ith <- sample(seq(nrow), size = cnt, replace = TRUE)
      jth <- sample(seq(ncol), size = cnt, replace = TRUE)
      r <- Matrix::sparseMatrix(i = ith, j = jth, x = 1)
      return(r)
    }, finally = {
      message("SuffleBmat is done.")
  })
  return(r)
}

#' Get enriched bin's percentage cutoff based on shuffledBmat.
#' @param sBmat sparseMatrix, cell by bins, randomly shuffled.
#' @param scale double, default is 3.0, scale the standard deviation.
#' @param noLessThan double, default is 0.04.
#' cutoff should be no less than this.
#' @return double
#' @export
getCutoffFromShuffledBmat <- function(sBmat, scale = 3.0,
                                      noLessThan = 0.04) {
  perct <- Matrix::colSums(sBmat) / nrow(sBmat)
  m <- mean(perct)
  std <- sd(perct)
  message("Mean of bin percentage: ", round(m, 5))
  message("Std of bin percentage: ", round(std, 5))
  r <- m + std * scale
  r <- max(noLessThan, r)
  message("Cutoff: ", round(r, 5))
  return(r)
}

#' Get number of diff bins and the pvalue given two groups.
#' @param bmat sparseMatrix, cell by bin
#' @param group vector of integer, cluster index of cells
#' @param ith integer, default 1
#' @param jth integer, default 2
#' @param threshold double, default 0.04
#' @param nperm integer, default 20
#' @return vector
#' first is number of diff bin, second is p-value
#' @export
getPvalueOfNDiff.default <- function(mat,
                                     group,
                                     ith = 1,
                                     jth = 2,
                                     threshold = 0.04,
                                     nperm = 20) {
  if (ith == jth) {
    message(ith, " and ", jth, " are the same group.")
    return(c(0, 1.0))
  }
  if (length(group) != nrow(mat)) {
    stop("Group length and nrow of mat does not match.")
  }
  ## only cells within the two groups are condisered
  ## this is specific for permutation test.
  rowIndex <- group %in% c(ith, jth)
  mat <- mat[rowIndex, ]
  group <- group[rowIndex]
  ni <- sum(group == ith)
  nj <- sum(group == jth)
  si <- which(Matrix::colSums(mat[group == ith, , drop = FALSE]) / ni >= threshold)
  sj <- which(Matrix::colSums(mat[group == jth, , drop = FALSE]) / nj >= threshold)
  ## total number of diff bins
  r <- length(si) + length(sj) - 2 * length(intersect(si, sj))
  message("Total number of diff bins between ",
    ith, " ith and ", jth, " jth group is: ", r)
  ## permutation test
  ## This can be accelarated by Rcpp.
  ndiffPerm <- vapply(seq(nperm), function(i_) {
    ## randomly shuffle group
    g <- sample(group, replace = F)
    si <- which(Matrix::colSums(mat[g == ith, , drop = FALSE]) / ni >= threshold)
    sj <- which(Matrix::colSums(mat[g == jth, , drop = FALSE]) / nj >= threshold)
    s <- length(si) + length(sj) - 2 * length(intersect(si, sj))
    return(s)
  }, FUN.VALUE = 0)
  message("Quantile of the random permutation: ")
  message(paste(quantile(ndiffPerm), collapse = ";"))
  p <- sum(ndiffPerm >= r) / nperm
  return(c(r, p))
}

#' Get number of diff bins and the pvalue for any two groups
#' @param bmat sparseMatrix, cell by bin
#' @param group vector of integer, cluster index of cells
#' @param uniqueGroupWithName vector, default NULL
#' unique names for group
#' @param threshold double, default 0.04
#' @param nperm integer, default 20
#' @return list of symmetric matrix
#' "diffbin" are number of diff bin, "p" are p-values.
#' each matrix has the names defined by names of uniqueGroupWithName
#' generated by this function.
#' @export
getPvalueOfNDiff.multiGroup <- function(mat, group,
                                        uniqueGroupWithName = NULL,
                                        threshold = 0.04,
                                        nperm = 20) {
  if (is.null(uniqueGroupWithName)) {
    uniqueGroupWithName <- sort(unique(group))
    names(uniqueGroupWithName) <- paste0("c", uniqueGroupWithName)
  }
  n <- length(uniqueGroupWithName)
  s <- matrix(data = 0, nrow = n, ncol = n,
    dimnames = list(names(uniqueGroupWithName),
      names(uniqueGroupWithName)))
  r <- matrix(data = 1, nrow = n, ncol = n,
    dimnames = list(names(uniqueGroupWithName),
      names(uniqueGroupWithName)))
  if (length(uniqueGroupWithName) > 1) {
    for (i in seq(n - 1)) {
      for (j in (i + 1):n) {
        ith <- uniqueGroupWithName[i]
        jth <- uniqueGroupWithName[j]
        message("Calculating p-values for the group ", ith, " and ",
          jth, " pair.")
        t <- getPvalueOfNDiff.default(mat = mat,
          group = group,
          ith = ith,
          jth = jth,
          threshold = threshold,
          nperm = nperm)
        s[i, j] <- t[1]
        r[i, j] <- t[2]
        ## symmetric
        s[j, i] <- s[i, j]
        r[j, i] <- r[i, j]
      }
    }
  }
  return(list(diffbin = s, p = r))
}

#' Based on pval matrix, link the nodes without significant p-values.
#' This is achieved by recursive way, which I think is too difficult.
#' Should have much simpler method.
#' @param pvalmat symmetric matrix
#' @param pthres double, default is 0.1
#' @return list of vectors, each vector is a graph module
#' defined by the pval matrix.
#' @export
getIsolatedGroup <- function(pvalmat, pthres = 0.1) {
  findCoModule <- function(graph, ith = 1) {
    if (ith == length(nodeUsed)) {
      if (nodeUsed[ith]) {
        return(c())
      }
      ## change a variable outside of function
      nodeUsed[ith] <<- TRUE
      return(c(ith))
    }
    candidates <- which(graph[ith, ] == 1)
    ## symmetric matrix, and only up-triangle will be considered here.
    candidates <- candidates[candidates > ith]


    if (length(candidates) < 1) {
      if (nodeUsed[ith]) {
        return(c())
      }
      nodeUsed[ith] <<- TRUE
      return(c(ith))
    }
    cc <- candidates[!nodeUsed[candidates]]
    if (length(cc) < 1) {
      if (nodeUsed[ith]) {return(c())}
      nodeUsed[ith] <<- TRUE
      return(c(ith))
    }
    r <- unlist(lapply(cc, function(i) {findCoModule(graph, i)}))
    if (nodeUsed[ith]) {
      return(r)
    }
    nodeUsed[ith] <<- TRUE
    return(c(ith, r))
  }

  if (nrow(pvalmat) == 1) {
    return(list(1))
  }

  graph <- 1 - (pvalmat <= pthres)
  diag(graph) <- 1
  nodeUsed <- rep(FALSE, nrow(pvalmat))
  r <- lapply(seq(nrow(pvalmat)), function(i) {
    s <- findCoModule(graph = graph, ith = i)
    if (length(s) < 1) {
      return(NULL)
    }
    return(s)
  })
  result <- r[!sapply(r, is.null)]
  return(result)
}
